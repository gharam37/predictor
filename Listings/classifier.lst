C51 COMPILER V9.59.0.0   CLASSIFIER                                                        11/19/2018 12:36:55 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLASSIFIER
OBJECT MODULE PLACED IN .\Objects\classifier.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE classifier.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\classifier.lst) TABS(2) OBJECT(.\Objects\classifier.obj)

line level    source

*** WARNING C500 IN LINE 1 OF classifier.c: INCORRECT LICENSE ID CODE (LIC) IN 'TOOLS.INI'
   1          #include <reg51.h>
   2          #include<stdio.h>
   3          
   4          //Feel free to change methods declarations
   5          unsigned char switch_training;  // 0: training, 1: testing
   6          unsigned char switch_user;      // 0: User A, 1: User B
   7          unsigned char trainingCount;    // Counts how many times did we get measurements from the user. Starts with 
             -0.
   8          unsigned char nextChar=0; // identifies which character we expect the user to enter (index of the characte
             -r) starts with 0.
   9          unsigned char word[3] = {'.','t','i'};  // Stores the characters of the word we want to use.
  10          unsigned int TimerEntryIndex = 0;  //Initial Time at which we started Program
  11          int StartCount = 2;  //Initial Time at which we started Program 2 means not in count mode 0-1 meaning we a
             -re waiting for input
  12          int CorrectSofar = 0;
  13          int StartTraining=0; // To Stop overflow and counter from increasing when we aren't putting input .. betwe
             -en 2 runs of entering a work
  14          unsigned long TimerArray[2] = {0,0};
  15          unsigned long FirstUserData[2] = {0,0}; // should change to 9
  16          unsigned long SecondUserData[2] = {0,0}; // should change to 9
  17          
  18          void CalculateAverage(unsigned int Values[])
  19          {
  20   1        int i =0;
  21   1        for(;i<2;i++){ //Length of array should change to 10
  22   2          if(switch_user==0){
  23   3          FirstUserData[i]+=Values[i]; //Divide by the number of training should change to 5 
  24   3            Values[i] = 0; //Clear for next Count
  25   3          }
  26   2          else{
  27   3            SecondUserData[i]=Values[i];
  28   3          }
  29   2            
  30   2        }
  31   1        
  32   1        
  33   1      }
  34          void ClearTimerArray(){
  35   1        int i=0;
  36   1        for(;i<2;i++)
  37   1          TimerArray[i]=0;
  38   1      
  39   1      }
  40          void runTraining(){}
  41          // called when the user enters the whole word in the testing phase it should predict who was the user
  42          void predict(){
  43   1       
  44   1      }
  45           
  46           // TODO: you know what character did we actually read now (using the variable nextChar [it is an index to
             - the character]) so you should measure the flight time and add it to training
  47          // for the current user and same for the test time
  48          void calculateTrainTime(){
C51 COMPILER V9.59.0.0   CLASSIFIER                                                        11/19/2018 12:36:55 PAGE 2   

  49   1      
  50   1        
  51   1      
  52   1       
  53   1      }
  54           
  55          void calculateTestTime(){
  56   1        
  57   1            if(StartCount==0 &&StartTraining==1){ 
  58   2             unsigned long OverFlowCount = 0;
  59   2      
  60   2            TR0 = 1;            //Start the timer
  61   2      
  62   2            while(StartCount == 0  ){
  63   3                  while(TF0 == 0);   // Wait for Timer Overflow
  64   3                  OverFlowCount++;
  65   3                  TF0 = 0;
  66   3            }       //wait till the key is released
  67   2            TR0 = 0;            //Stop the timer
  68   2            if(CorrectSofar == 1){
  69   3            TimerArray[TimerEntryIndex]=((TH0 << 8) | TL0)+0x0000FFFF*OverFlowCount; //Load timer into Array
  70   3              TimerEntryIndex++;
  71   3      
  72   3            }
  73   2            if(TimerEntryIndex ==2){ // IF Reached our maximum letter
  74   3                TimerEntryIndex = 0;
  75   3                //////// Call The Method that calculates the ecludien distance in here          
  76   3              
  77   3              }
  78   2            TH0 = 0;                //Reset the timer.
  79   2            TL0 = 0;  
  80   2            TF0=0;
  81   2            StartCount=0;
  82   2            OverFlowCount=0;
  83   2          } 
  84   1       
  85   1      }
  86          void CalculateTime(){
  87   1        if( switch_training){
  88   2          calculateTestTime();
  89   2        
  90   2        }
  91   1      
  92   1        if(StartCount==0 &&StartTraining==1){ 
  93   2             unsigned long OverFlowCount = 0;
  94   2      
  95   2            TR0 = 1;            //Start the timer
  96   2      
  97   2            while(StartCount == 0  ){
  98   3                  while(TF0 == 0);   // Wait for Timer Overflow
  99   3                  OverFlowCount++;
 100   3                  TF0 = 0;
 101   3            }       //wait till the key is released
 102   2            TR0 = 0;            //Stop the timer
 103   2            if(CorrectSofar == 1){
 104   3            TimerArray[TimerEntryIndex]=+((TH0 << 8) | TL0)+0x0000FFFF*OverFlowCount; //Load timer into Array
 105   3              TimerEntryIndex++;
 106   3      
 107   3            }
 108   2            if(TimerEntryIndex ==2){ // IF Reached our maximum letter
 109   3                TimerEntryIndex = 0;
 110   3                if(trainingCount==2) // if we finished Training for user A to be changed to 5
C51 COMPILER V9.59.0.0   CLASSIFIER                                                        11/19/2018 12:36:55 PAGE 3   

 111   3                {
 112   4                  trainingCount = 0; 
 113   4                  CalculateAverage(TimerArray);
*** WARNING C182 IN LINE 113 OF classifier.c: pointer to different objects
 114   4                  ClearTimerArray();
 115   4                  if(!switch_user){ // If we r still in User A
 116   5                  switch_user=1; //Go to b
 117   5                  }
 118   4                  else{
 119   5                     switch_training = 1; // If we finished B .. go to training
 120   5                  }
 121   4                }           
 122   3              
 123   3              }
 124   2            TH0 = 0;                //Reset the timer.
 125   2            TL0 = 0;  
 126   2            TF0=0;
 127   2            StartCount=0;
 128   2            OverFlowCount=0;
 129   2          } 
 130   1      
 131   1      }
 132          
 133          void uartConfig(void) {
 134   1        
 135   1        SCON  = 0x50;     // Serial Port: Mode 1 (8 bits), use Timer 1 for baudrate, enable reception (bit 4)
 136   1        IE    = 0x90;     // enable global interrupt and serial receive interrupt
 137   1        
 138   1        // Baudrate = 2400 (bits/second ?) => 240 characters per second
 139   1        // Fosc     = 12 MHz
 140   1        
 141   1        // Baudrate = Fosc / (N * (256 ? TH1))
 142   1        // For (SMOD1 = 0) N = 384 : TH1 = 242.979 => 243 = 0xF3  <- We'll use this value
 143   1        // For (SMOD1 = 1) N = 192 : TH1 = 229.958 => 230 = 0xE6
 144   1        
 145   1        PCON &= 0x7F;     // set SMOD1 in PCON to 0..
 146   1                          // Tells that we are using N = 384.
 147   1                          // What does it mean? I don't know xD
 148   1        
 149   1        TMOD |= 0x21;     // timer 1, mode 2, 8-bit reload , timer 0 for counting
 150   1        TH1   = 0xF3;     // baud rate: reload value for 2400 baud @ 12MHz (to change?)
 151   1        TR1   = 1;        // start timer 1
 152   1        TL0 = 0x00;              //Initialise TIMER0 in 16 bit mode 
 153   1        TH0 = 0x00;
 154   1      }
 155          
 156          
 157          void decide(unsigned char received){
 158   1        int idx;
 159   1        for(idx = 0; idx<3; idx++)
 160   1        {
 161   2          if(word[idx] == received){
 162   3            CorrectSofar = 0;
 163   3            break;
 164   3          }
 165   2        }
 166   1        // wrong character
 167   1        if(idx != nextChar)
 168   1        {
 169   2          nextChar = 0;
 170   2          StartCount=2; //Reset Count
 171   2          CorrectSofar = 0;
C51 COMPILER V9.59.0.0   CLASSIFIER                                                        11/19/2018 12:36:55 PAGE 4   

 172   2          TimerArray[0]=0;
 173   2          TimerArray[1]=0;
 174   2      
 175   2          //printf("%s","type the word again please");
 176   2          return;
 177   2        }
 178   1        // calculate the flight time between this character and the previous one
 179   1        CorrectSofar = 1;
 180   1          StartCount=1; 
 181   1          StartTraining =1 ; //Stop when we finished one work for one user
 182   1      
 183   1        if(!switch_training){
 184   2          
 185   2        
 186   2          //calculateTrainTime(); // Called in MainMethod
 187   2        } else {
 188   2          calculateTestTime();
 189   2        }
 190   1        
 191   1        nextChar++;
 192   1        if(nextChar==1){
 193   2          StartCount=0;
 194   2        }
 195   1        // if we reach the last char 
 196   1        // increment the training count if it is training phase
 197   1        // call predict if we are in the testing phase
 198   1        if(nextChar == 3){ //Should Change to 10
 199   2          nextChar = 0;
 200   2          StartTraining =0 ; //Stop when we finished one work for one user
 201   2          if(!switch_training){
 202   3            trainingCount++;
 203   3            
 204   3          }
 205   2          else{
 206   3            predict();
 207   3            return;
 208   3          } 
 209   2        }
 210   1        //finalizing training after 5 inputs for the word
 211   1        if(trainingCount == 2){
 212   2          //runTraining();
 213   2          //trainingCount = 0;
 214   2          nextChar = 0;
 215   2          StartTraining = 0 ; //Stop when we finished a training for one user
 216   2          // switch to training phase of user B
 217   2          /*if(!switch_user &&!switch_training){         //Commented Cuz I already do this in my timer 
 218   2            //printf("%s","user B starts training");
 219   2            //switch_user = 1;
 220   2          } else {
 221   2          // both A and B did the training, switch to testing
 222   2            //printf("%s","Testing phase started");
 223   2            switch_training = 1;
 224   2          }*/ 
 225   2          
 226   2        }
 227   1        
 228   1      }
 229          
 230          // Option 2: interrupt-based
 231          void receive() interrupt 4 {
 232   1        unsigned char received = SBUF;
 233   1         RI = 0;
C51 COMPILER V9.59.0.0   CLASSIFIER                                                        11/19/2018 12:36:55 PAGE 5   

 234   1         StartCount =1;
 235   1      
 236   1        //printf("%s","Here");
 237   1        decide(received);
 238   1      }
 239          
 240          // method to read the ports and decide
 241          
 242          
 243          
 244          void main() {
 245   1        
 246   1      
 247   1        
 248   1        uartConfig();
 249   1        
 250   1        while(1)
 251   1        {
 252   2          CalculateTime();
 253   2            
 254   2        }
 255   1        
 256   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    815    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     39      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
